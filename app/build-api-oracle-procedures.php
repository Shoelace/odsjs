<?php

/**
 * BUILDING AN API AROUND ORACLE PACKAGES AND PROCEDURES
 * -----------------------------------------------------
 * 
 * Proof of concept showing how Oracle stored procedures can be automatically generated by PHP by passing in an array of standard select SQL queries. Results are retrieved as a PL/SQL cursor which can then be fetched into a PHP multidimensional array.
 *
 * This is a one-page procedural demo which creates a dummy users table, seeds it with data, creates several procedures for data access (based on an array of select SQL queries) and finally returns the results into a multidimensional PHP array for each query, displaying them on screen.
 *
 * The idea is to bake this into a Laravel object-oriented package which will integrate with the migration (table creation) and data seeding packages included with Laravel.
 * 
 * Concept: You pass the queries you need to run into a Laravel migration (you could even write the queries using Laravel's Eloquent ORM, http://laravel.com/docs/eloquent). When the migration was run, the tables would be created, but also the necessary procedures would be created automatically (as below) within a package. Laravel's Eloquent can handle table relationships and much more.
 *
 * Then, building a RESTful API through which to access the data would be relatively straightforward using Laravel's Resource controllers (http://laravel.com/docs/controllers#resource-controllers). Authentication for accessing sensitive data could be handled via the OAuth 2.0 Server Laravel package (https://github.com/lucadegasperi/oauth2-server-laravel).
 *
 * Instructions for use:
 *     1) Enter database credentials below for your Oracle database (ensure that is a clean database/schema, as tables and packages will be dropped/created!!!);
 *     2) Upload the PHP file to the server;
 *     3) Browse to the PHP page. The tables and packages will be created on the specified database schema and the results shown on screen.
 *
 * Reference:
 * http://php.net/manual/en/function.oci-new-cursor.php
 * http://uk3.php.net/oci_bind_by_name#83094
 * http://www.toadworld.com/platforms/oracle/w/wiki/3328.dbms-sql-describe-columns.aspx
 * http://psoug.org/definition/SYS_REFCURSOR.htm
 * http://www.oracle.com/technetwork/articles/fuecks-sps-095636.html
 * 
 * @author Michael Wolfindale <mwolfindale@gmail.com>
 */

//echo "<h1>Auto-generation of Oracle procedures based on a given model</h1>";


// Database credentials.
require_once('config.inc.php');

$model = json_decode(file_get_contents('php://input'), true);
//print_r($model);

// Model name and associated queries (relates to the database table, and the package which will contain the stored procedures, based on the queries, to access the data).
/*
 * $model = array(

    'name' => 'odsjs',
    'queries' => array(),
);


// Specify the queries you want to make into stored procedures.
$model['queries']['selectJobs'] = array( 'sql' => "select owner,job_name, job_style, program_owner,program_name, job_type, job_action,number_of_arguments, schedule_name, schedule_type, start_date, repeat_interval, enabled,state, run_count, last_start_date, last_run_duration, next_run_date, logging_level, EVENT_QUEUE_OWNER, EVENT_QUEUE_NAME,EVENT_QUEUE_AGENT,EVENT_CONDITION,FILE_WATCHER_OWNER, FILE_WATCHER_NAME from dba_scheduler_jobs order by owner desc"
                                    );
$model['queries']['selectNotifcations'] = 
        array( 'sql' => "select recipient,sender, subject, body, filter_condition, LISTAGG(event, ', ') within group (order by EVENT_FLAG) events 
                  from DBA_SCHEDULER_NOTIFICATIONS 
                   where 1=1 
                   and owner = ? 
                   and job_name = ? 
                   group by owner,job_name, job_subname, recipient,sender, subject, body, filter_condition"
       , 'in' => array('jowner', 'jname')
            );
 */                         

// Show model details on screen.
//echo "<h2>IN: Model info</h2>";
//echo "<strong>(Database table name and SQL queries for accessing the data)</strong><br/><pre>";

//var_dump($model);
//echo "</pre>";


// Connect to database.
$conn = oci_pconnect(DB_USER, DB_PASS, DB_CONNECTIONSTRING);
if (!$conn) {
    $m = oci_error();
    trigger_error(htmlentities($m['message']), E_USER_ERROR);
}


// Package name.
$packageName = $model['name'].'_pkg';


// Create package header, adding procedure parameters for each query.
$createPkgHeader = "CREATE OR REPLACE PACKAGE $packageName AS\n\n";
foreach ($model['queries'] as $procedureName => $query) {
     $procedureParams[$procedureName] = "\tPROCEDURE $procedureName(\n";

    // Add input parameters, if any were specified.
    if (isset($query['in'])) {
        $query['in_sql'] = array();
        foreach ($query['in'] as $key => $param) {
           $procedureParams[$procedureName] .= "\t\ti_{$key} IN VARCHAR2,\n";
        }
    }

    $procedureParams[$procedureName] .= "\t\to_results_cursor OUT SYS_REFCURSOR\n\t)";
    
    $createPkgHeader .= "{$procedureParams[$procedureName]};\n\n";
    
}
$createPkgHeader .= "\nEND $packageName;";

//echo "<h2>OUT: Package header code</h2><pre>$createPkgHeader</pre>";

$stid = oci_parse($conn, $createPkgHeader);
oci_execute($stid)
//echo oci_execute($stid) ? "<p><em>Package header $packageName compiled.</em></p>" : "<p><em>Error.</em></p>";


// Create package body, adding procedure parameters for each query.
$createPkgBody = "CREATE OR REPLACE PACKAGE BODY $packageName AS\n\n";

foreach ($model['queries'] as $procedureName => $query) {
    $createPkgBody .= "{$procedureParams[$procedureName]}  IS BEGIN\n";
    
    if (isset($query['in'])) {
        $model['queries'][$procedureName]['sql'] = interpolateQuery($query['sql'], $query['in']);
        $query['sql'] = interpolateQuery($query['sql'], $query['in'], 'i_#');;
    }

    $createPkgBody .= "\t\tOPEN o_results_cursor FOR {$query['sql']};\n";
    
    $createPkgBody .= "\tEND {$procedureName};\n\n";
}

$createPkgBody .= "\nEND $packageName;";

//echo "<h2>OUT: Package body code</h2><pre>$createPkgBody</pre>";
$stid = oci_parse($conn, $createPkgBody);
oci_execute($stid)
//echo oci_execute($stid) ? "<p><em>Package body $packageName compiled.</em></p>" : "<p><em>Error.</em></p>";

oci_close($conn);

//print (json_encode(['header' :$createPkgHeader, 'body' :$createPkgBody ]));
print (json_encode([ 'header' =>$createPkgHeader , 'body' =>$createPkgBody]));
/**
 * Replaces any parameter placeholders in a query with the value of that
 * parameter. Useful for debugging. Assumes anonymous  parameters from 
 * $params are are in the same order as specified in $query.
 *
 * Optionally replaces anonymous parameters with a string. This string can be numbered (according to the order of parameters) if the string includes '%i'.
 *
 * http://stackoverflow.com/questions/210564/getting-raw-sql-query-string-from-pdo-prepared-statements/210693#210693
 *
 * @param string $query The SQL query with parameter placeholders
 * @param array $params The array of substitution parameters
 * @param string $replace Optionally replace parameter placeholders with a string (which will ne numbered if it includes '#')
 * @return string The interpolated query
 */
function interpolateQuery($query, $params, $replace = null) {
    $keys = array();
    $values = $params;

    # build a regular expression for each parameter
    foreach ($params as $key => $value) {
        if (is_string($key)) {
            $keys[] = '/:'.$key.'/';
        } else {
            $keys[] = '/[?]/';
        }

        if (is_array($value))
            $values[$key] = implode(',', $value);

        if (is_null($value))
            $values[$key] = 'NULL';
    }

    if ($replace) {
        $count = 0;
        while (preg_match($match = '/[?]/', $query)) {
            $param = preg_replace('/#/', $count, $replace, 1);
            $query = preg_replace($match, $param, $query, 1);
            $count++;
        }
    } else {
        // Walk the array to see if we can add single-quotes to strings
        array_walk($values, create_function('&$v, $k', 'if (!is_numeric($v) && $v!="NULL") $v = "\'".$v."\'";'));

        $query = preg_replace($keys, $values, $query, 1, $count);
    }

    return $query;
}



?>
